include: macros_impl/am.def
include: macros_impl/barrier.def
include: macros_impl/hsl.def

page: runtime_impl.h, from templates/runtime_impl.h
    module: cpp
    output_dir: ./realm_src

page: runtime_impl.cc, from templates/runtime_impl.cc
    module: cpp
    output_dir: ./realm_src

    $(block:global_init)
        #include <mpi.h>

# page: activemsg.h, from templates/activemsg.h
page: activemsg.cc, from templates/activemsg.cc
    module: cpp
    output_dir: ./realm_src

    subcode: activemsg_decl_gasnet
        $template templates/activemsg_decl_gasnet.cc
    subcode: activemsg_decl_mpi
        #include <mpi.h>
        typedef int gasnet_node_t;
        typedef int32_t gasnet_handlerarg_t;
        $call activemsg_decl_other
    subcode: activemsg_decl_other
        #include <pthread.h>
        #define GASNETHSL_IMPL     pthread_mutex_t mutex
        #define GASNETCONDVAR_IMPL pthread_cond_t  condvar
    # ----------------------------
    subcode: activemsg_impl_gasnet
        $(set:USE_GASNET=1)
        $call HSL_impl, gasnet
        $template templates/activemsg_impl_gasnet.cc
    subcode: activemsg_impl_mpi
        $(set:USE_MPI=1)
        $call HSL_impl, pthread
        $call activemsg_impl_other
    subcode: activemsg_impl_other
        $call HSL_impl, pthread
        $template templates/activemsg_impl_other.cc

# page: mem_impl.h, from templates/mem_impl.h
page: mem_impl.cc, from templates/mem_impl.cc
    module: cpp
    output_dir: ./realm_src

#---- runtime_impl.cc ------------------------- 
subcode: network_init_mpi
    MPI_Init(NULL, NULL)
    MPI_Comm_size(MPI_COMM_WORLD, &max_node_id)
    MPI_Comm_rank(MPI_COMM_WORLD, &my_node_id)
    $print "network_init_mpi: %d/%d", my_node_id, max_node_id
    max_node_id--

#---- activemsg.cc ---------------------------- 
subcode: class_EndpointManager
    $template templates/activemsg_endpoint_manager.cc

subcode: class_ActiveMessageEndpoint
    $template templates/activemsg_endpoint.cc

subcode: class_IncomingMessageManager
    $template templates/activemsg_incoming_manager.cc
subcode: impl_IncomingMessageManager
    $template templates/activemsg_incoming_manager_impl.cc

subcode: class_Payload
    $template templates/activemsg_payload.cc

subcode: class_SrcDataPool
    $template templates/activemsg_srcdatapool.cc
    subcode: hsl_sdp(cmd)
        $(if:USE_GASNET)
            gasnet_hsl_$(cmd)(&sdp.mutex);
        $(else)
            pthread_mutex_$(cmd)(&sdp.mutex);

subcode: struct_OutgoingMessage
    $template templates/activemsg_outgoing.cc
subcode: impl_OutgoingMessage
    $template templates/activemsg_outgoing_impl.cc

subcode: class_DetailedMessageTiming
    $template templates/activemsg_timing.cc
#---------------------------------------- 
subcode: init_endpoints_mpi
    $call @parse_command_line
    $call @init_srcdatapool
    # $call @add_handlers

    subcode: add_handlers
        $typedef void (*HANDLER_T)()
        $global const int MAX_HANDLERS=256
        $global HANDLER_T am_mpi_handlers[MAX_HANDLERS] 
        $(for:H in FLIP_REQ, FLIP_ACK, RELEASE_SRCPTR)
            $(if:H=RELEASE_SRCPTR)
                $(set:h=handler_$(H:lc))
            $(else)
                $(set:h=SrcDataPool::release_srcptr_handler)
            am_mpi_handlers[MSGID_$(H)] = (void (*)())$(h)

subcode: mpi_add_handler_entry # msgid, fnptr
    $list f_get_msgid
    $print "mpi_add_handler_entry: %d - %s", msgid, f_get_msgid(msgid)

subcode: mpi_enqueue_message(payload_type)
    $call to_debug
    assert(0 && "mpi_enqueue_message - $(payload_type) - active messages not available!");

#---------------------------------------- 
subcode: to_debug
    $include <unistd.h>, <stdlib.h>
    $block
        $my int i = 0
        $print "[rank %d] use \"gdb out/main %d\" to debug ...", my_node_id, getpid()
        $while 0==i
            sleep(5)

#---------------------------------------- 
template: activemsg_mpi
    void enqueue_message(NodeID target, int msgid,
                        const void *args, size_t arg_size,
                        const void *payload, size_t payload_size,
                        int payload_mode, void *dstptr)
    {
        $call mpi_enqueue_message, ContiguousPayload
    }

    void enqueue_message(NodeID target, int msgid,
                        const void *args, size_t arg_size,
                        const void *payload, size_t line_size,
                        off_t line_stride, size_t line_count,
                        int payload_mode, void *dstptr)
    {
        $call mpi_enqueue_message, TwoDPayload
    }

    void enqueue_message(NodeID target, int msgid,
                        const void *args, size_t arg_size,
                        const SpanList& spans, size_t payload_size,
                        int payload_mode, void *dstptr)
    {
        $call mpi_enqueue_message, SpanPayload
    }

    void do_some_polling(void)
    {
    assert(0 && "compiled without USE_GASNET - active messages not available!");
    }

    size_t get_lmb_size(NodeID target_node)
    {
    return 0;
    }

    void record_message(NodeID source, bool sent_reply)
    {
    }

    void send_srcptr_release(token_t token, uint64_t srcptr)
    {
    }

    NodeID get_message_source(token_t token)
    {
    return 0;
    }

    void enqueue_incoming(NodeID sender, IncomingMessage *msg)
    {
    assert(0 && "compiled without USE_GASNET - active messages not available!");
    }

    bool adjust_long_msgsize(NodeID source, void *&ptr, size_t &buffer_size,
                            int message_id, int chunks)
    {
    return false;
    }

    void handle_long_msgptr(NodeID source, const void *ptr)
    {
    assert(0 && "compiled without USE_GASNET - active messages not available!");
    }

    void add_handler_entry(int msgid, void (*fnptr)())
    {
        $call mpi_add_handler_entry
    }

    void init_endpoints(int gasnet_mem_size_in_mb,
                        int registered_mem_size_in_mb,
                        int registered_ib_mem_size_in_mb,
                        Realm::CoreReservationSet& crs,
                        std::vector<std::string>& cmdline)
    {
        $call init_endpoints_mpi
    }

    void start_polling_threads(int)
    {
    }

    void start_handler_threads(int, Realm::CoreReservationSet&, size_t)
    {
    }

    void stop_activemsg_threads(void)
    {
    }

#---- Common ------------------------------------ 
macros:
    # 64 msgid: 140-204
    msgid_list: NODE_ANNOUNCE_MSGID, SPAWN_TASK_MSGID, LOCK_REQUEST_MSGID, LOCK_RELEASE_MSGID, LOCK_GRANT_MSGID, EVENT_SUBSCRIBE_MSGID, EVENT_TRIGGER_MSGID, EVENT_UPDATE_MSGID, REMOTE_MALLOC_MSGID, REMOTE_MALLOC_RPLID, CREATE_ALLOC_MSGID, CREATE_ALLOC_RPLID, CREATE_INST_MSGID, CREATE_INST_RPLID, VALID_MASK_REQ_MSGID, VALID_MASK_DATA_MSGID, VALID_MASK_FTH_MSGID, ROLL_UP_TIMER_MSGID, ROLL_UP_DATA_MSGID, CLEAR_TIMER_MSGID, DESTROY_INST_MSGID, REMOTE_WRITE_MSGID, REMOTE_REDUCE_MSGID, REMOTE_SERDEZ_MSGID, REMOTE_WRITE_FENCE_MSGID, REMOTE_WRITE_FENCE_ACK_MSGID, DESTROY_LOCK_MSGID, REMOTE_REDLIST_MSGID, MACHINE_SHUTDOWN_MSGID, BARRIER_ADJUST_MSGID, BARRIER_SUBSCRIBE_MSGID, BARRIER_TRIGGER_MSGID, BARRIER_MIGRATE_MSGID, METADATA_REQUEST_MSGID, METADATA_RESPONSE_MSGID, METADATA_INVALIDATE_MSGID, METADATA_INVALIDATE_ACK_MSGID, XFERDES_REMOTEWRITE_MSGID, XFERDES_REMOTEWRITE_ACK_MSGID, XFERDES_CREATE_MSGID, XFERDES_DESTROY_MSGID, XFERDES_NOTIFY_COMPLETION_MSGID, XFERDES_UPDATE_BYTES_WRITE_MSGID, XFERDES_UPDATE_BYTES_READ_MSGID, REGISTER_TASK_MSGID, REGISTER_TASK_COMPLETE_MSGID, REMOTE_MICROOP_MSGID, REMOTE_MICROOP_COMPLETE_MSGID, REMOTE_SPARSITY_CONTRIB_MSGID, REMOTE_SPARSITY_REQUEST_MSGID, APPROX_IMAGE_RESPONSE_MSGID, SET_CONTRIB_COUNT_MSGID, REMOTE_ID_REQUEST_MSGID, REMOTE_ID_RESPONSE_MSGID, REMOTE_IB_ALLOC_REQUEST_MSGID, REMOTE_IB_ALLOC_RESPONSE_MSGID, REMOTE_IB_FREE_REQUEST_MSGID, REMOTE_COPY_MSGID, REMOTE_FILL_MSGID, MEM_STORAGE_ALLOC_REQ_MSGID, MEM_STORAGE_ALLOC_RESP_MSGID, MEM_STORAGE_RELEASE_REQ_MSGID, MEM_STORAGE_RELEASE_RESP_MSGID

fncode: f_get_msgid(int id): const char*
    $switch id
        $(for:$(msgid_list))
            case $1: return "$1"
    return NULL

