include: macros_impl/hsl.def
include: macros_impl/util.def

macros:
    # debug: 1

#---------------------------------------- 
page: activemsg_impl_mpi.cc
    output_dir: ./realm_src
    module: cpp
    USE_MPI: 1

    $include "am_mpi.h"
    $include <mpi.h>
    NEWLINE
    $(for:activemsg, cmdline,threads,timers,logging)
        $include "realm/$1.h"
    NEWLINE

    $list AM_MPI_Init
    $template templates/activemsg_impl_mpi.cc

fncode: AM_MPI_Init
    $(if:0)
        MPI_Init(NULL, NULL)
    $(else)
        $my int mpi_thread_model
        MPI_Init_thread(NULL, NULL, MPI_THREAD_MULTIPLE, &mpi_thread_model)
        assert(mpi_thread_model==MPI_THREAD_MULTIPLE)
    MPI_Comm_size(MPI_COMM_WORLD, &max_node_id)
    MPI_Comm_rank(MPI_COMM_WORLD, &my_node_id)
    $(if:debug)
        $print "network_init_mpi: %d/%d", my_node_id, max_node_id
    max_node_id--
    $call @on_am_init

#---------------------------------------- 
subcode: init_endpoints_mpi
    $call @parse_command_line
    # $call @init_srcdatapool
    # $call @add_handlers
    g_am_manager.init_corereservation(crs)

subcode: mpi_add_handler_entry # msgid, fnptr
    $list f_get_msgid
    $(if:debug)
        $print "mpi_add_handler_entry: %d - %s", msgid, f_get_msgid(msgid)
    AM_add_handler(msgid, fnptr)

subcode: mpi_enqueue_message(payload_type)
    $global int next_outgoing_message_id = 0
    int n_args = arg_size/4;
    # $call to_debug
    $(if:debug)
        $print "enqueue_message %d->%d [$(payload_type)-%d] - %d %s-", my_node_id, target, payload_mode, msgid, f_get_msgid(msgid)
        $call debug_args

    $(set:is_short=payload_mode==PAYLOAD_NONE)
    $call set_payload_size

    $(if:AM_ENQUEUE)
        $call am_enqueue, target, msgid, n_args, args, $(is_short), payload, payload_size
    $(else)
        $call send_now

    subcode: send_now
        $(set:args=(const int*)args)
        $if $(is_short)
            AM_short_n(n_args, target, msgid, $(args))
        $else
            $call adjust_args
            AM_medium_n(n_args, target, msgid, payload,payload_size, $(args))

    subcode: set_payload_size
        $(if:payload_type=ContiguousPayload)
            NOOP
        $(elif:payload_type=TwoDPayload)
            $my size_t payload_size = line_size*line_count
        $(else)
            $my const void *payload = NULL
            assert(0 && "mpi_enqueue_message - $(payload_type) - active messages not available!");

    subcode: debug_args
        $print " - %d:-", n_args
        $for i=0:n_args
            $print " %8x-", ((int*)args)[i]
        $print

    subcode: adjust_args
        $my int* tp_args = (int*)(args)
        $if tp_args[0]==BaseMedium::MESSAGE_ID_MAGIC
            NOOP
        $else
            assert(tp_args[2]==BaseMedium::MESSAGE_ID_MAGIC)
            tp_args += 2
        tp_args[0] = next_outgoing_message_id++
        tp_args[1] = 1
        tp_args[2] = 0
        tp_args[3] = 0

subcode: mpi_thread_loop
    $while true
        $if shutdown_flag
            break
        $(if:AM_ENQUEUE)
            $call am_dequeue
        AMPoll();

# called in machine_impl.cc - await_all_annoucements
subcode: mpi_do_some_polling
    # AMPoll()

subcode: mpi_get_message_source
    return (int)(long)token

subcode: mpi_enqueue_incoming
    $(if:debug)
        $print "[%d] running msg handler", my_node_id
    msg->run_handler()
    # assert(0 && "compiled without USE_GASNET - active messages not available!");

subcode: mpi_handle_long_msgptr
    $(if:debug)
        $print "mpi_handle_long_msgptr"
    # assert(0 && "compiled without USE_GASNET - active messages not available!");

subcode: mpi_adjust_long_msgsize
    return true
    # assert(0 && "adjust_long_msgsize not available")

subcode: mpi_record_message
    $(if:debug)
        $print "mpi_record_message %d", sent_reply

subcode: mpi_start_polling_threads
    $(if:debug)
        $print "start_polling_threads."
    g_am_manager.start_threads();

subcode: mpi_start_handler_threads
    $(if:debug)
        $print "start_handler_threads %d", count

subcode: mpi_stop_activemsg_threads
    $(if:debug)
        $print "stop_activemsg_threads "
    # assert(0)
    g_am_manager.stop_threads();


#---- Common ------------------------------------ 
macros:
    # 64 msgid: 140-204
    msgid_list: NODE_ANNOUNCE_MSGID, SPAWN_TASK_MSGID, LOCK_REQUEST_MSGID, LOCK_RELEASE_MSGID, LOCK_GRANT_MSGID, EVENT_SUBSCRIBE_MSGID, EVENT_TRIGGER_MSGID, EVENT_UPDATE_MSGID, REMOTE_MALLOC_MSGID, REMOTE_MALLOC_RPLID, CREATE_ALLOC_MSGID, CREATE_ALLOC_RPLID, CREATE_INST_MSGID, CREATE_INST_RPLID, VALID_MASK_REQ_MSGID, VALID_MASK_DATA_MSGID, VALID_MASK_FTH_MSGID, ROLL_UP_TIMER_MSGID, ROLL_UP_DATA_MSGID, CLEAR_TIMER_MSGID, DESTROY_INST_MSGID, REMOTE_WRITE_MSGID, REMOTE_REDUCE_MSGID, REMOTE_SERDEZ_MSGID, REMOTE_WRITE_FENCE_MSGID, REMOTE_WRITE_FENCE_ACK_MSGID, DESTROY_LOCK_MSGID, REMOTE_REDLIST_MSGID, MACHINE_SHUTDOWN_MSGID, BARRIER_ADJUST_MSGID, BARRIER_SUBSCRIBE_MSGID, BARRIER_TRIGGER_MSGID, BARRIER_MIGRATE_MSGID, METADATA_REQUEST_MSGID, METADATA_RESPONSE_MSGID, METADATA_INVALIDATE_MSGID, METADATA_INVALIDATE_ACK_MSGID, XFERDES_REMOTEWRITE_MSGID, XFERDES_REMOTEWRITE_ACK_MSGID, XFERDES_CREATE_MSGID, XFERDES_DESTROY_MSGID, XFERDES_NOTIFY_COMPLETION_MSGID, XFERDES_UPDATE_BYTES_WRITE_MSGID, XFERDES_UPDATE_BYTES_READ_MSGID, REGISTER_TASK_MSGID, REGISTER_TASK_COMPLETE_MSGID, REMOTE_MICROOP_MSGID, REMOTE_MICROOP_COMPLETE_MSGID, REMOTE_SPARSITY_CONTRIB_MSGID, REMOTE_SPARSITY_REQUEST_MSGID, APPROX_IMAGE_RESPONSE_MSGID, SET_CONTRIB_COUNT_MSGID, REMOTE_ID_REQUEST_MSGID, REMOTE_ID_RESPONSE_MSGID, REMOTE_IB_ALLOC_REQUEST_MSGID, REMOTE_IB_ALLOC_RESPONSE_MSGID, REMOTE_IB_FREE_REQUEST_MSGID, REMOTE_COPY_MSGID, REMOTE_FILL_MSGID, MEM_STORAGE_ALLOC_REQ_MSGID, MEM_STORAGE_ALLOC_RESP_MSGID, MEM_STORAGE_RELEASE_REQ_MSGID, MEM_STORAGE_RELEASE_RESP_MSGID

fncode: f_get_msgid(int id): const char*
    $switch id
        $(for:$(msgid_list))
            case $1: return "$1"
    return NULL

